{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Introduction to Time Series Analysis\"\n",
        "format:\n",
        "  revealjs:\n",
        "    theme: [default, ../assets/custom.scss]\n",
        "    footer: \"Data Science Transforming Maintenance\"\n",
        "    logo: ../assets/logo.png\n",
        "    menu: true\n",
        "    slide-number: true\n",
        "    show-side-number: all\n",
        "    number-sections: true\n",
        "    number-depth: 1\n",
        "    include-after-body: ../assets/clean_title_page.html\n",
        "    echo: false\n",
        "    # argument for reveal-header\n",
        "    sc-sb-title: true\n",
        "title-slide-attributes:\n",
        "  data-background-image: ../assets/title_background.png\n",
        "  data-background-size: contain\n",
        "  data-background-opacity: \"1.0\"\n",
        "# reveal-header extension\n",
        "filters: \n",
        "  - reveal-header\n",
        "# argument for reveal-header  \n",
        "slide-level: 2    \n",
        "jupyter: python3\n",
        "---"
      ],
      "id": "22bd2936"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: False\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt"
      ],
      "id": "101c2662",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Outline\n",
        "\n",
        "\n",
        "1. Time series data\n",
        "2. Statistical models for time series\n",
        "3. Characterising and identifying time series\n",
        "4. Example\n",
        "\n",
        "\n",
        "# Time series data\n",
        "\n",
        "## What is a time series? \n",
        "\n",
        "::: {style=\"font-size: 80%\"}\n",
        "- Time series data can be thought of as data measured at regular intervals of time\n",
        "\n",
        "- Arise in many areas: science, engineering, finance, banking, environment, health\n",
        "\n",
        "- Because we are sampling at adjacent points in time, \\emph{serial} correlation is introduced\n",
        "    \n",
        "- Example: daily maximum temperatures over a year constitute a time series \n",
        "\n",
        "- Time series data consist of a list of numbers $\\{x_t\\}$ and information about the times those numbers were recorded\n",
        ":::\n",
        "\n",
        "::: {style=\"font-size: 90%\"}\n",
        "## Visual display of time series\n",
        "\n",
        "- The first step in analysis of time series data is to plot the data!\n",
        "\n",
        "- What to look for:\n",
        "\n",
        "    - linear and nonlinear trends: long-term increase or decrease in the data\n",
        "    - seasonality: when a series is influenced by seasonal factors, e.g., month, day of the week\n",
        "    - cycles/quasi-periodicities: data exhibits rises and falls that are *not* of fixed period\n",
        "    - changes in variability, irregular fluctuations\n",
        ":::    \n",
        "\n",
        "## Passenger counts for MEL-SYD \n"
      ],
      "id": "369c9630"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "df = pd.read_csv(\"data/ansett.csv\")\n",
        "\n",
        "# Convert 'ds' column to datetime\n",
        "df['ds'] = pd.to_datetime(df['ds'])\n",
        "\n",
        "# Filter for Melbourne-Sydney route and Economy class\n",
        "mel_syd_economy = df[(df['Airports'] == 'MEL-SYD') & (df['Class'] == 'Economy')]\n",
        "\n",
        "# Plot using seaborn\n",
        "# Create the plot using constrained_layout instead of tight_layout\n",
        "fig, ax = plt.subplots(figsize=(14, 5.5), constrained_layout=True)\n",
        "sns.lineplot(data=mel_syd_economy, x='ds', y='y', ax=ax)\n",
        "# ax.set_title('Passenger Counts for Melbourne-Sydney (Economy Class)')\n",
        "ax.set_xlabel('Date')\n",
        "ax.set_ylabel('Passenger Count')\n",
        "ax.grid(True)\n",
        "plt.show()"
      ],
      "id": "679edcb2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Australia beer production\n"
      ],
      "id": "eaac585b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load the dataset\n",
        "beer_df = pd.read_csv(\"data/aus_production.csv\")\n",
        "\n",
        "# Convert 'ds' to datetime format\n",
        "beer_df['ds'] = pd.to_datetime(beer_df['ds'])\n",
        "\n",
        "# Plot the Beer production time series\n",
        "plt.figure(figsize=(14, 5.5))\n",
        "sns.lineplot(data=beer_df, x='ds', y='Beer')\n",
        "# plt.title('Beer Production in Australia (1956–Present)')\n",
        "plt.xlabel('Date')\n",
        "plt.ylabel('Beer Production')\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "9ac552aa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Australian beer production by quarter\n"
      ],
      "id": "6c9c2e8d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create necessary time-related columns\n",
        "beer_df['Year'] = beer_df['ds'].dt.year\n",
        "beer_df['Quarter'] = beer_df['ds'].dt.quarter\n",
        "beer_df['Quarter_Label'] = beer_df['Quarter'].map({1: 'Q1', 2: 'Q2', 3: 'Q3', 4: 'Q4'})\n",
        "\n",
        "# Plot beer production over time by quarter\n",
        "plt.figure(figsize=(16, 5.5))\n",
        "sns.lineplot(data=beer_df, x='Year', y='Beer', hue='Quarter_Label', marker='o')\n",
        "plt.xlabel('Year')\n",
        "plt.ylabel('Beer Production')\n",
        "plt.grid(True)\n",
        "plt.legend(title='Quarter')\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "3a7d9bd3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Southern Oscillation Index\n"
      ],
      "id": "c0219bcc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load and parse the SOI text file\n",
        "with open(\"data/soi.txt\", \"r\") as file:  # Use the full path if needed\n",
        "    lines = file.readlines()\n",
        "\n",
        "# Parse lines into a DataFrame\n",
        "data = []\n",
        "for line in lines:\n",
        "    parts = line.strip().split()\n",
        "    if len(parts) == 13:\n",
        "        year = int(parts[0])\n",
        "        monthly_values = [float(val.replace('+', '')) for val in parts[1:]]\n",
        "        for month, value in enumerate(monthly_values, 1):\n",
        "            data.append({'Date': pd.Timestamp(year=year, month=month, day=1), 'SOI': value})\n",
        "\n",
        "soi_df = pd.DataFrame(data)\n",
        "\n",
        "# ✅ Filter from 1960 onwards\n",
        "soi_recent = soi_df[soi_df['Date'] >= '1960-01-01']\n",
        "\n",
        "# Plot the filtered data\n",
        "plt.figure(figsize=(16, 5.5))\n",
        "plt.plot(soi_recent['Date'], soi_recent['SOI'], linewidth=1)\n",
        "# plt.title('Southern Oscillation Index (Monthly Averages, 1960–Present)')\n",
        "plt.xlabel('Date')\n",
        "plt.ylabel('SOI')\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "feed82c4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Stock price of NASDAQ company\n"
      ],
      "id": "ec23755c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load the Google stock data\n",
        "gafa_df = pd.read_csv(\"data/gafa_stock.csv\")\n",
        "\n",
        "# Convert date column to datetime\n",
        "gafa_df['ds'] = pd.to_datetime(gafa_df['ds'])\n",
        "\n",
        "# Filter for Google's daily closing prices up to mid-2015\n",
        "google_df = gafa_df[gafa_df['unique_id'] == 'GOOG_Close']\n",
        "google_filtered = google_df[google_df['ds'] <= '2015-06-30']\n",
        "\n",
        "# Plot the time series\n",
        "plt.figure(figsize=(14, 5.5))\n",
        "plt.plot(google_filtered['ds'], google_filtered['y'], linewidth=1)\n",
        "# plt.title(\"Google Daily Closing Stock Price (Start – Mid-2015)\")\n",
        "plt.xlabel(\"Date\")\n",
        "plt.ylabel(\"Closing Price (USD)\")\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "a7faab85",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## First differences of stock price\n"
      ],
      "id": "fbe84608"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute the first differences of the closing prices\n",
        "google_filtered['Price_Diff'] = google_filtered['y'].diff()\n",
        "\n",
        "# Plot the first differences\n",
        "plt.figure(figsize=(14, 5.5))\n",
        "plt.plot(google_filtered['ds'], google_filtered['Price_Diff'], linewidth=1)\n",
        "# plt.title(\"First Differences of Google Daily Closing Stock Price (Start – Mid-2015)\")\n",
        "plt.xlabel(\"Date\")\n",
        "plt.ylabel(\"Price Change (USD)\")\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "8f9f2ec5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## White noise series\n"
      ],
      "id": "a95c15e0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Generate white noise with the same length as the Google filtered dataset\n",
        "np.random.seed(42)\n",
        "white_noise = np.random.normal(loc=0, scale=1, size=len(google_filtered))\n",
        "\n",
        "# Create a time series with the same dates\n",
        "white_noise_df = pd.DataFrame({\n",
        "    'Date': google_filtered['ds'].values,\n",
        "    'White_Noise': white_noise\n",
        "})\n",
        "\n",
        "# Plot the white noise series\n",
        "plt.figure(figsize=(14, 5.5))\n",
        "plt.plot(white_noise_df['Date'], white_noise_df['White_Noise'], linewidth=1)\n",
        "# plt.title(\"Simulated White Noise Series (Same Length as Google Data)\")\n",
        "plt.xlabel(\"Date\")\n",
        "plt.ylabel(\"Value\")\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "986ca1ce",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Statistical models for time series\n",
        "\n",
        "## Objectives of time series analysis\n",
        "\n",
        "::: {style=\"font-size: 90%\"}\n",
        "* **Description**: What is the structure of the series? Is there a trend? Are there seasonalities in the series?\n",
        "\n",
        "* **Explanation**: Can we use the variation in one time series to explain the variation in another series, as in a time series regression model?\n",
        "\n",
        "* **Forecasting**: Given an observed time series, can we forecast future values of that series, e.g., can we the SOI for the next year?\n",
        "\n",
        "* **Control**: What is the impact of changes in one series on the characteristics of another, e.g., impact of monetary policy on unemployment rate?\n",
        ":::\n",
        "\n",
        "## Correlation in time series\n",
        "\n",
        "* In contrast to the white noise series, all the series we have seen have some kind structure\n",
        "\n",
        "* This structure arises from the fact that adjacent observations are correlated, or observations in different (for example) quarters are correlated\n",
        "\n",
        "* The difference in this correlation structure gives rise to series with different overall structure\n",
        "\n",
        "* Important to understand how this different correlational structure arises\n",
        "\n",
        "## Serial correlation\n",
        "\n",
        "* Two ways in which correlation can be induced in time series\n",
        "  1. *Moving average*: a moving average series is constructed by averaging observations in seqential time windows of the same width\n",
        "  2. *Autoregression*: in a purely autoregressive series, the current value depends in some way on past values\n",
        "  \n",
        "## Autoregressive series\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "\n",
        "::: {style=\"font-size: 85%\"}\n",
        "* Here's an example of a purely autoregressive series:\n",
        "$$\n",
        "x_t = 0.5 x_{t-1} -0.30 x_{t-2} + \\epsilon_t\n",
        "$$\n",
        "* The current value of the series depends linearly on the past two values of the series, plus some white noise\n",
        "* AR(2) series\n",
        ":::\n",
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "179e67ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from statsmodels.tsa.arima_process import ArmaProcess\n",
        "\n",
        "# Define stationary AR(2) coefficients: (1 - 0.5L + 0.3L^2)\n",
        "ar_params_stationary = np.array([1, -0.5, 0.3])\n",
        "ma_params_stationary = np.array([1])  # No MA component\n",
        "\n",
        "# Create and simulate the AR(2) process\n",
        "ar2_stationary_process = ArmaProcess(ar=ar_params_stationary, ma=ma_params_stationary)\n",
        "ar2_stationary_series = ar2_stationary_process.generate_sample(nsample=300, scale=1.0, burnin=100, distrvs=np.random.normal)\n",
        "\n",
        "# Plot the stationary AR(2) series\n",
        "plt.figure(figsize=(5.5, 5.5))\n",
        "plt.plot(ar2_stationary_series, linewidth=1)\n",
        "# plt.title(\"Simulated Stationary AR(2) Series (ϕ₁ = 0.5, ϕ₂ = -0.3)\")\n",
        "plt.xlabel(\"Time\")\n",
        "plt.ylabel(\"Value\")\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "ae280ae3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "## Moving average series\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.column width=\"50%\"}\n",
        "\n",
        "::: {style=\"font-size: 85%\"}\n",
        "* Here's an example of a purely moving average series:\n",
        "$$\n",
        "x_t = \\epsilon_t + 1.5 \\epsilon_{t-1} -0.56 \\epsilon_{t-2}\n",
        "$$\n",
        "\n",
        "* The current value of the series is a weighted average of white noise 'shocks'\n",
        "* MA(2) series\n",
        ":::\n",
        "\n",
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "af732b1e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define MA(2) coefficients: MA polynomial is (1 + 1.5L - 0.56L^2)\n",
        "ar_params = np.array([1])  # No AR component\n",
        "ma_params = np.array([1, 1.5, -0.56])\n",
        "\n",
        "# Create the MA process and simulate\n",
        "ma2_process = ArmaProcess(ar=ar_params, ma=ma_params)\n",
        "ma2_series = ma2_process.generate_sample(nsample=300, scale=1.0, distrvs=np.random.normal)\n",
        "\n",
        "# Plot the MA(2) series\n",
        "plt.figure(figsize=(5.5, 5.5))\n",
        "plt.plot(ma2_series, linewidth=1)\n",
        "# plt.title(\"Simulated MA(2) Series (θ₁ = 1.5, θ₂ = -0.56)\")\n",
        "plt.xlabel(\"Time\")\n",
        "plt.ylabel(\"Value\")\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "9223db1f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "## ARMA(2, 2) series\n"
      ],
      "id": "53bc6685"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define stationary AR(2) coefficients: (1 - 0.5L + 0.3L^2)\n",
        "ar_params_stationary = np.array([1, -0.5, 0.3])\n",
        "ma_params_stationary = np.array([1])  # No MA component\n",
        "\n",
        "# Create and simulate the AR(2) process\n",
        "ar2_stationary_process = ArmaProcess(ar=ar_params_stationary, ma=ma_params_stationary)\n",
        "ar2_stationary_series = ar2_stationary_process.generate_sample(nsample=300, scale=1.0, burnin=100, distrvs=np.random.normal)\n",
        "\n",
        "# Plot the stationary AR(2) series\n",
        "plt.figure(figsize=(10, 5))\n",
        "plt.plot(ar2_stationary_series, linewidth=1)\n",
        "# plt.title(\"Simulated Stationary AR(2) Series (ϕ₁ = 0.5, ϕ₂ = -0.3)\")\n",
        "plt.xlabel(\"Time\")\n",
        "plt.ylabel(\"Value\")\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "c4fae59c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<center>\n",
        "::: {style=\"font-size: 50%\"}\n",
        "$X_t = 0.5 X_{t-1} - 0.3 X_{t-2} + \\varepsilon_t + 1.5 \\varepsilon_{t-1} - 0.56 \\varepsilon_{t-2}$\n",
        ":::\n",
        "</center>\n",
        "\n",
        "## Stationarity {.smaller}\n",
        "\n",
        "* ARMA modelling of time series data can only be applied for series that are *stationary*\n",
        "\n",
        "* A stationary series is:\n",
        "  * roughly horizontal (no trends)\n",
        "  * has constant variance\n",
        "  \n",
        "* Differencing helps to stabilize the mean (removes some types of trends)\n",
        " \n",
        "* Transformations (such as logarithms) help to stabilize the variance\n",
        "\n",
        "* Identify a nonstationary series by:\n",
        "  * plotting the data!\n",
        "  * examining the *autocorrelation* function\n",
        "  \n",
        "# Characterising and identifying time series\n",
        "\n",
        "## Measures of dependence {.smaller}\n",
        "\n",
        "- One of the key steps in analysis of time series is to examine the correlation structure of the series by calculating and displaying autocorrelations and \\emph{partial} autocorrelations at different lags\n",
        "    \n",
        "- Recall that covariance and correlation measure the extent of \\textbf{linear} association between two variables (e.g., $x$ and $y$ as in linear regression)\n",
        "\n",
        "- Autocovariance and autocorrelation measure linear relationship between \\emph{lagged} values of a time series $\\{x_t\\}$, e.g., between\n",
        "\n",
        "    - $x_t$ and $x_{t-1}$\n",
        "    - $x_t$ and $x_{t-2}$\n",
        "    - $x_t$ and $x_{t-3}$\n",
        "    - $\\ldots$\n",
        "  \n",
        "## Example: autocorrelation in SOI series\n"
      ],
      "id": "a299643b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create lagged versions of the SOI series\n",
        "soi_df['Lag1'] = soi_df['SOI'].shift(1)\n",
        "soi_df['Lag2'] = soi_df['SOI'].shift(2)\n",
        "\n",
        "# Drop missing values\n",
        "soi_lagged = soi_df.dropna()\n",
        "\n",
        "# Calculate correlations\n",
        "corr_lag1 = soi_lagged['SOI'].corr(soi_lagged['Lag1'])\n",
        "corr_lag2 = soi_lagged['SOI'].corr(soi_lagged['Lag2'])\n",
        "\n",
        "# Plot lag 1 scatterplot\n",
        "plt.figure(figsize=(12, 5))\n",
        "plt.subplot(1, 2, 1)\n",
        "sns.scatterplot(x='Lag1', y='SOI', data=soi_lagged, alpha=0.5)\n",
        "plt.title(f\"Lag 1 Scatterplot\\nCorrelation = {corr_lag1:.2f}\")\n",
        "plt.xlabel(\"SOI (Lag 1)\")\n",
        "plt.ylabel(\"SOI\")\n",
        "\n",
        "# Plot lag 2 scatterplot\n",
        "plt.subplot(1, 2, 2)\n",
        "sns.scatterplot(x='Lag2', y='SOI', data=soi_lagged, alpha=0.5)\n",
        "plt.title(f\"Lag 2 Scatterplot\\nCorrelation = {corr_lag2:.2f}\")\n",
        "plt.xlabel(\"SOI (Lag 2)\")\n",
        "plt.ylabel(\"SOI\")\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "6763c7c0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## SOI series: autocorrelation function\n"
      ],
      "id": "1e2067fe"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from statsmodels.graphics.tsaplots import plot_acf, plot_pacf\n",
        "\n",
        "# Filter the SOI series from 1960 onwards\n",
        "soi_1960_onward = soi_df[soi_df['Date'] >= '1960-01-01'].dropna()\n",
        "\n",
        "# Plot ACF separately\n",
        "# plt.figure(figsize=(12, 4))\n",
        "plot_acf(soi_1960_onward['SOI'], lags=40)\n",
        "plt.title(\"ACF of SOI (1960–Present)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "60f67194",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Partial autocorrelations\n",
        "\n",
        "- Correlation between two random variables can sometimes be due to the fact that both variables are correlated with the same third variable \n",
        "\n",
        "- In time series, it could be that the correlation between $x_t$ and $x_{t+h}$ is due to the correlation that these variables have with the variables 'in between', i.e., $x_{t+1}, x_{t+1}, \\ldots, x_{t+h-1}$\n",
        "\n",
        "- This gives rise to the notion of a **partial autocorrelation**, which measures the relationship between $x_t$ and $x_{t+h}$ when the effects of the lags in between are removed\n",
        "\n",
        "## SOI series: partial autocorrelations\n"
      ],
      "id": "f0e894a3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Plot PACF separately\n",
        "# plt.figure(figsize=(12, 4))\n",
        "plot_pacf(soi_1960_onward['SOI'], lags=40, method='ywm')\n",
        "plt.title(\"PACF of SOI (1960–Present)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "198a1814",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Identifying time series models {.smaller}\n",
        "\n",
        "* The shapes of the ACF and PACF give us a clue as to the structure of a stationary time series\n",
        "\n",
        "* The strategy for identifying the order of an ARMA model would be:\n",
        "  * carry out differencing and or transformation to remove trend and/or nonconstant variance\n",
        "  * calculate and display the ACF and PACF\n",
        "  * interpret the ACF and PACF in order to identify the order of the ARMA(p, q) model\n",
        "  * fit the initial model, check diagnostics, and re-fit if necessary\n",
        "  * produce $h$-step ahead forecasts and uncertainty intervals\n",
        "\n",
        "* In contemporary time series analysis, there are now functions to 'automatically' select the 'optimal' ARMA model from which forecasts can be made\n",
        "\n",
        "# Example\n",
        "\n",
        "## Exports from Egypt\n"
      ],
      "id": "78eef620"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Load the uploaded CSV file\n",
        "egypt_exports_df = pd.read_csv(\"data/egypt_exports.csv\")\n",
        "\n",
        "# Plot the time series of exports\n",
        "plt.figure(figsize=(12, 5.5))\n",
        "plt.plot(egypt_exports_df['ds'], egypt_exports_df['Exports'], marker='o', linestyle='-')\n",
        "# plt.title(\"Exports from Egypt (Arab Rep.) Over Time\")\n",
        "plt.xlabel(\"Year\")\n",
        "plt.ylabel(\"Exports (% of GDP)\")\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "9d44467b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exports: ACF\n"
      ],
      "id": "4367c379"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Plot ACF with lags=20\n",
        "plot_acf(egypt_exports_df['Exports'], lags=20)\n",
        "# plt.title(\"ACF of Egypt's Exports (% of GDP)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "5befb267",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exports: PACF\n"
      ],
      "id": "93c7a537"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Plot PACF with lags=20\n",
        "plot_pacf(egypt_exports_df['Exports'], lags=20, method='ywm')\n",
        "# plt.title(\"PACF of Egypt's Exports (% of GDP)\")\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "7728ba02",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exports: automatic selection of model\n"
      ],
      "id": "79358dd3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "from pmdarima import auto_arima\n",
        "\n",
        "# Fit an ARIMA model using automatic selection\n",
        "arima_model = auto_arima(\n",
        "    egypt_exports_df['Exports'],\n",
        "    seasonal=False,\n",
        "    stepwise=True,\n",
        "    suppress_warnings=True,\n",
        "    error_action='ignore',\n",
        "    trace=True\n",
        ")\n",
        "arima_model.summary()"
      ],
      "id": "91df7513",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from statsmodels.tsa.arima.model import ARIMA\n",
        "import numpy as np\n",
        "\n",
        "# Prepare the data\n",
        "y = egypt_exports_df['Exports'].dropna().values\n",
        "\n",
        "# Define range of parameters for grid search\n",
        "p_values = range(0, 4)\n",
        "d_values = range(0, 2)\n",
        "q_values = range(0, 4)\n",
        "\n",
        "# Perform grid search based on AIC\n",
        "best_aic = np.inf\n",
        "best_order = None\n",
        "best_model = None\n",
        "\n",
        "for p in p_values:\n",
        "    for d in d_values:\n",
        "        for q in q_values:\n",
        "            try:\n",
        "                model = ARIMA(y, order=(p, d, q)).fit()\n",
        "                if model.aic < best_aic:\n",
        "                    best_aic = model.aic\n",
        "                    best_order = (p, d, q)\n",
        "                    best_model = model\n",
        "            except Exception:\n",
        "                continue\n",
        "\n",
        "# best_order, best_aic"
      ],
      "id": "10668546",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {style=\"font-size: 40%\"}"
      ],
      "id": "5faf1277"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "best_model.summary()"
      ],
      "id": "f24b2881",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Exports: comparing data and fit\n"
      ],
      "id": "2ab631bf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Generate in-sample predictions (fitted values)\n",
        "fitted_values = best_model.fittedvalues\n",
        "\n",
        "# Create a time series index for plotting\n",
        "years = egypt_exports_df['ds'].iloc[-len(fitted_values):]  # align with fitted values\n",
        "\n",
        "# Plot original series and fitted values\n",
        "plt.figure(figsize=(12, 5.5))\n",
        "plt.plot(egypt_exports_df['ds'], egypt_exports_df['Exports'], label='Original', marker='o')\n",
        "plt.plot(years, fitted_values, label='Fitted', linestyle='--', marker='x')\n",
        "plt.title(\"Original vs Fitted Values - ARIMA(2,0,1) Model\")\n",
        "plt.xlabel(\"Year\")\n",
        "plt.ylabel(\"Exports (% of GDP)\")\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "cc46dd7d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exports: forecasting for next 10 years\n"
      ],
      "id": "bf930635"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Forecast the next 10 years using the best_model\n",
        "forecast_result = best_model.get_forecast(steps=10)\n",
        "forecast_mean = forecast_result.predicted_mean\n",
        "forecast_ci = forecast_result.conf_int(alpha=0.10)  # 90% prediction intervals\n",
        "\n",
        "# Generate time index for forecast\n",
        "last_year = egypt_exports_df['ds'].iloc[-1]\n",
        "forecast_years = np.arange(last_year + 1, last_year + 11)\n",
        "\n",
        "# If forecast_ci is a NumPy array, use direct indexing\n",
        "lower_bounds = forecast_ci[:, 0].astype(float)\n",
        "upper_bounds = forecast_ci[:, 1].astype(float)\n",
        "forecast_mean_values = forecast_mean.astype(float)\n",
        "\n",
        "# Plot original data and forecast\n",
        "plt.figure(figsize=(12, 5.5))\n",
        "plt.plot(egypt_exports_df['ds'], egypt_exports_df['Exports'], label='Original', marker='o')\n",
        "plt.plot(forecast_years, forecast_mean_values, label='Forecast', linestyle='--', marker='x')\n",
        "plt.fill_between(forecast_years, lower_bounds, upper_bounds,\n",
        "                 color='gray', alpha=0.3, label='90% Prediction Interval')\n",
        "plt.title(\"Forecast of Egypt's Exports (% of GDP) for Next 10 Years\")\n",
        "plt.xlabel(\"Year\")\n",
        "plt.ylabel(\"Exports (% of GDP)\")\n",
        "plt.legend()\n",
        "plt.grid(True)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "fc944d33",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Key points\n",
        "\n",
        "::: {style=\"font-size:75%\"}\n",
        "* We have only scratched the surface of time series analysis; there's much more to be said and learned!\n",
        "\n",
        "* ARMA models can be used to model stationary series; if the series is nonstationary, pre-processing is required, e.g., log transformation to stabilize variance and/or differencing (once, or even twice) to remove linear or quadratic trends\n",
        "\n",
        "* ACF and PACF of stationary series can be used to estimate an initial ARMA model\n",
        "\n",
        "* Even with automated model selection methods, there may be more than one fits just as well and produces similar forecasts\n",
        "\n",
        "* Automated selection methods do not absolve us of the responsibility of carrying out diagnostic checks!\n",
        ":::"
      ],
      "id": "42bfc8c9"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/usr/local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}